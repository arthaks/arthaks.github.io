<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Arrays.asList() 使用注意]]></title>
    <url>%2F2019%2F07%2F01%2FArrays.asList%20%E5%A4%A7%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Arrays.asList() 在需对规范中都不是首推使用的方法，这里面有很多很多的坑需要踩 123456789101112131415161718192021222324252627282930313233 /** * Returns a fixed-size list backed by the specified array. (Changes to * the returned list "write through" to the array.) This method acts * as bridge between array-based and collection-based APIs, in * combination with &#123;@link Collection#toArray&#125;. The returned list is * serializable and implements &#123;@link RandomAccess&#125;. * * &lt;p&gt;This method also provides a convenient way to create a fixed-size * list initialized to contain several elements: * &lt;pre&gt; * List&amp;lt;String&amp;gt; stooges = Arrays.asList("Larry", "Moe", "Curly"); * &lt;/pre&gt; * * @param &lt;T&gt; the class of the objects in the array * @param a the array by which the list will be backed * @return a list view of the specified array */ @SafeVarargs @SuppressWarnings("varargs") public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a); &#125; // 以上方法中的return 的构造器 ArrayList(E[] array) &#123; a = Objects.requireNonNull(array); &#125;// 以上方法中的 数组非null 判断public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj; &#125; 可以看到注释中 Returns a fixed-size list backed by the specified array. 可变参数列表可变参数列表使用的底层机制为数组传递 1234public static &lt;T&gt; String toList(T...a)&#123; T[] a1 = a; // idea 自动补齐的功能键, 返回的是数据,可以明确看出来 可变参数列表的底层机制是数组, 编程思想中也提到过可变参数列表的实现机制为数组 return a1[0].toString();&#125; 数组特点为创建后length不可变, 如果(T…a) 参数传入 的是(obj, null, obj, null), 那么实际的入参为一个长度 是4 的数组, 即 [obj, null, obj, null]. 这样以来就能看出Arrays.asList(T…a) 方法中的问题传入 带有null元素的数组, 但是整体数组非null, 最终形成一个List size()为4, 但是 2, 4 位上的元素为null, 一般情况下, 拿到list, 使用CollectionUtils.isEmpty()进行判断, 以上的带有null元素的数组通过判断, 进行迭代的时候通常就不会判断元素的null了, 容易造成空指针异常. 1234567891011 List&lt;Integer&gt; listOfKeng = Arrays.asList(null, null, null); List&lt;Integer&gt; list = Arrays.asList(1, 2, 3); System.out.println(listOfKeng); System.out.println(list); System.out.println(listOfKeng.size()); System.out.println(list.size());// [null, null, null]// [1, 2, 3]// 3// 3 123456789101112131415161718192021项目中的大坑public List&lt;LendUserInfo&gt; getLenderAndBorrowerInfoByLogUserAccount(LogUserAccountDetailStorm logUserAccountDetailStorm) &#123; // 获取理财用户 LendUserInfo lendUserInfo = null; try &#123; lendUserInfo = buildLendUserInfo(someObj, 1, 1); &#125; catch (Exception e) &#123; logger.warn("getLenderAndBorrowerInfoByLogUserAccount, userInfo invalid, userGid:&#123;&#125;, orderId:&#123;&#125;" , logUserAccountDetailStorm.getUserGid(), logUserAccountDetailStorm.getOrderId(), e); return null; &#125; LendUserInfo borrowerInfo = null; try &#123; borrowerInfo = this.buildLendUserInfoByMatch(someObj); &#125; catch (Exception e) &#123; logger.error("getLenderAndBorrowerInfoByLogUserAccount, userInfo invalid, userGid:&#123;&#125;, orderId:&#123;&#125;" , logUserAccountDetailStorm.getUserGid(), logUserAccountDetailStorm.getOrderId()); return null; &#125; return Arrays.asList(lendUserInfo, borrowerInfo); // 这里线上出现过 lendUserInfo 有数据, borrowerInfo = null的情况 即返回了[obj, null]&#125; 1有很多情况下, 从数据库查询出来的entity直接放到了Arrays.asList(T...a) 中了, 非常容易造成空指针异常]]></content>
      <categories>
        <category>java 基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java SPI 机制]]></title>
    <url>%2F2019%2F07%2F01%2Fjava%20SPI%20%2F</url>
    <content type="text"><![CDATA[java SPI(Service Provider Interfaces) 服务提供接口,jdk自身提供的一种获取到某个service 接口的实现类的方式. 使用方法 在项目的META-INF/services/ 下创建文件,文件名为目标service 的全限定名 在文件中写入对应的实现类的权限定名 使用ServiceLoader.load(Class class) 获取到全部的实现类 demo创建 service 接口 123public interface ComputerService &#123; void sayName();&#125; 创建对应实现类 1234567891011121314public class Dell implements ComputerService &#123; @Override public void sayName() &#123; System.out.println("我是 dell"); &#125;&#125;public class MacBook implements ComputerService &#123; @Override public void sayName() &#123; System.out.println("我是大mac"); &#125;&#125; 创建文件 获取对应的实现类 1234567891011121314151617181920212223public class Main &#123; public static void main(String[] args) &#123; System.out.println("Hello World!"); ServiceLoader&lt;ComputerService&gt; loadService = ServiceLoader.load(ComputerService.class); for (ComputerService computerService : loadService) &#123; computerService.sayName(); System.out.println("---------------------------我是666的分割线, dubbo 中扩展了java SPI机制,形成类似的AOP/Ioc机制------------------------------------"); &#125;// Hello World!// 我是大mac// ---------------------------我是666的分割线, dubbo 中扩展了java SPI机制,形成类似的AOP/Ioc机制------------------------------------// 我是 dell// ---------------------------我是666的分割线, dubbo 中扩展了java SPI机制,形成类似的AOP/Ioc机制------------------------------------ &#125;&#125; ServiceLoader 源码解析for 循环使用了ServiceLoader 的迭代器, 静默使用了hasNext(), next() 等方法, 在LazyInterator中有分别对应的hasNextService(), nextService() 最终调用指向 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798private class LazyIterator implements Iterator&lt;S&gt; &#123; Class&lt;S&gt; service; // ClassLoader loader; // 类加载器 Enumeration&lt;URL&gt; configs = null; // 文件中的配置好的类转化成的url Iterator&lt;String&gt; pending = null; // 包含类名的迭代器 String nextName = null; private LazyIterator(Class&lt;S&gt; service, ClassLoader loader) &#123; this.service = service; this.loader = loader; &#125; private boolean hasNextService() &#123; if (nextName != null) &#123; return true; &#125; if (configs == null) &#123; try &#123; String fullName = PREFIX + service.getName(); // private static final String PREFIX = "META-INF/services/"; if (loader == null) configs = ClassLoader.getSystemResources(fullName); else configs = loader.getResources(fullName); &#125; catch (IOException x) &#123; fail(service, "Error locating configuration files", x); &#125; &#125; while ((pending == null) || !pending.hasNext()) &#123; if (!configs.hasMoreElements()) &#123; return false; &#125; pending = parse(service, configs.nextElement()); &#125; nextName = pending.next(); return true; &#125; private S nextService() &#123; if (!hasNextService()) throw new NoSuchElementException(); String cn = nextName; nextName = null; Class&lt;?&gt; c = null; try &#123; c = Class.forName(cn, false, loader); // forName 实例化对应的实现类 &#125; catch (ClassNotFoundException x) &#123; fail(service, "Provider " + cn + " not found"); &#125; if (!service.isAssignableFrom(c)) &#123; fail(service, "Provider " + cn + " not a subtype"); &#125; try &#123; S p = service.cast(c.newInstance()); // cast to 对应的接口 providers.put(cn, p); // private LinkedHashMap&lt;String,S&gt; providers = new LinkedHashMap&lt;&gt;(); 有序链表 return p; &#125; catch (Throwable x) &#123; fail(service, "Provider " + cn + " could not be instantiated", x); &#125; throw new Error(); // This cannot happen &#125; public boolean hasNext() &#123; // 迭代for循环 指向 hasNestService(); if (acc == null) &#123; return hasNextService(); &#125; else &#123; PrivilegedAction&lt;Boolean&gt; action = new PrivilegedAction&lt;Boolean&gt;() &#123; public Boolean run() &#123; return hasNextService(); &#125; &#125;; return AccessController.doPrivileged(action, acc); &#125; &#125; public S next() &#123; // 迭代for循环 指向 nextService(); if (acc == null) &#123; return nextService(); &#125; else &#123; PrivilegedAction&lt;S&gt; action = new PrivilegedAction&lt;S&gt;() &#123; public S run() &#123; return nextService(); &#125; &#125;; return AccessController.doPrivileged(action, acc); &#125; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; &#125; demo:https://github.com/arthaks/java-demo/tree/master/java-demo-SPI]]></content>
      <categories>
        <category>java 基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 下搭建hexo进行博客书写]]></title>
    <url>%2F2019%2F06%2F26%2Flinux-%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E8%BF%9B%E8%A1%8C%E5%8D%9A%E5%AE%A2%E4%B9%A6%E5%86%99%2F</url>
    <content type="text"><![CDATA[自己想写博客, 试过简书, 博客园, CSDN, google blogger 等乱七八糟的东西, 不是广告太多就是不支持markdown. 后来知道了hexo, 这篇文章就是测试文章. 需求如下: 使用markdown写东西, 用了好长时间了, 改不了了 广告不要太多, 最好没有 最好远端和本地或者其他网络空间里能多处备份(现在这样看来, 这种方法可以存在本地, github, 印象笔记, 有道笔记等支持markdown存储的地方) 跨平台操作(linux, win, mac 都支持) 目前我个人使用的是linux mint 19 作为日常使用电脑, 所以以下操作均基于该系统, 当然这玩意其实就是Ubuntu的一个衍生版本,给予Ubuntu的所有版本基本都是这样搞. 基本步骤 准备node.js 环境(hexo基于这玩意咋地还是) 安装hexo 自备markdown编辑器, 自行google选择, 我自己在用 haroopad 有自己的github, 自行google 安装git, 自行google 详细搞1. 准备node.js 环境linux 相对简单, 在node.js 官网 下载对应tar包, 然后解压, 我的解压完成之后是 /home/arthaks/soft/node-v10.16.0-linux-x64将 node.js配置环境变量, ln 创建软硬链接用法, 自行google. 12sudo ln -s /home/arthaks/soft/node-v10.16.0-linux-x64/bin/node /usr/local/bin/sudo ln -s /home/arthaks/soft/node-v10.16.0-linux-x64/bin/npm /usr/local/bin/ 2. 安装hexo,并启动对应引擎123# 安装hexo,并配置hexo环境变量npm install hexo-cli -gsudo ln -s /home/arthaks/soft/node-v10.16.0-linux-x64/bin/hexo /usr/local/bin/ 创建自己的文件夹初始化文件夹作为博客位置, hexo命令学习可以看官方文档,也可以 hexo help 查看对应的命令使用[hexo help 命令学习个人赶脚效率很高,看个人习惯] 1234567mkdir blogcd blog# init 文件夹为hexo工作空间hexo init# Start the server and watch for file changes.hexo s# 然后会提示你用本地4000接口查看博客了, 当然这是本地启动hexo server之后的效果, 博客的原理还是使用hexo引擎将对应的markdown文件转化成html文件配置到远端 3. markdown疯狂输出就ok了markdown 语法自己找就行啦, 贼简单 4. 生成博客, md文件都在 /home/arthaks/Doc/blog/source/_posts/12hexo ghexo s 5. 配置主题 hexo找到对应主题git clone 主题到我们博客文件夹下的themes里, 然后找到博客根目录下的_config.yml 修改文件中theme配置为刚clone的文件名, 然后重新生成博客并启动hexo server 就能本地看出变化来啦]]></content>
      <categories>
        <category>闲篇瞎扯</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>github</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
