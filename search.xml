<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java 8 函数式编程使用]]></title>
    <url>%2F2019%2F07%2F10%2Fjava8%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%20%2F</url>
    <content type="text"><![CDATA[java 8 引入了函数式编程， 可以将函数当做参数传入到一个方法中， 主要引入Stream API， 用来处理Collection数据，简化并优化处理数据的方式，目前大量框架均已经引入相关API的使用 Lambda 表达式 Lambda 表达式——一种紧凑的、传递行为的方式 Lambda表达式基本构成： 入参 -&gt; Lambda表达是链接符号 行为12(x, y) -&gt; x + y;(Long x, Long y) -&gt; x + y; // 入参可以声明参数类型， 也可以不输入， 会有自动的类型推导 变种写法（这些变种只是简化基本构成的表达方法） 如果参数是单个的， 即只有一个入参， 那么可以省略入参括号 1e -&gt; work; 行为过于复杂可以使用{}进行包裹 1e -&gt; &#123;work&#125;; 函数式接口对于java等语言，定义一个变量，必须为该变量提供一个类型(type)，尽管js等 由var这样的type关键字，但还是需要提供一个这种type，上述的Lambda表达式，描述的是一种行为，比如求和、做其他事情等。那么声明一个Lambda表达式 需要用什么type呢？以下是java 官方 对函数式接口的引入的部分描述，可以在各个函数式接口的doc中找到这段描述的链接 Functional interfaces provide target types for lambda expressions and method references. Each functional interface has a single abstract method, called the functional method for that functional interface, to which the lambda expression’s parameter and return types are matched or adapted. Functional interfaces can provide a target type in multiple contexts, such as assignment context, method invocation, or cast context: // Assignment context Predicate&lt;String&gt; p = String::isEmpty; // Method invocation context stream.filter(e -&gt; e.getSize() &gt; 10)... // Cast context stream.map((ToIntFunction) e -&gt; e.getSize())... FunctionalInterface 注解java8引入@FunctionalInterface 注解作为函数式接口的定义的元素，该注解描述函数式接口中只能声明一个方法，但是允许由default 关键字描述的方法、static描述的方法，或者重写了从java.lang.Object继承来的方法， 所以可以在java 提供的函数式接口中看到很多接口中包含不止一个方法声明，同时还有许多default 和static 描述的非抽象方法(是的，java8支持在接口中声明static 和default描述的非抽象方法)。举个例子：我们如果写一个Lambda 表达式，用来描述判断 输入的年龄是否大于30岁，直接书写 1Predicate&lt;Integer&gt; func = age -&gt; age &gt; 30; 简单看下Predicate 的代码 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Represents a predicate (boolean-valued function) of one argument. * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt; * whose functional method is &#123;@link #test(Object)&#125;. * @param &lt;T&gt; the type of the input to the predicate * 代表一个 根据输入参数的断言行为， 这个行为的函数方法是 test(T t), t作为输入参数 */@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return &#123;@code true&#125; if the input argument matches the predicate 将输入的参数和写的断言逻辑进行匹配 * 上边写的表达式返回一个boolean， 实际可以理解为写的 age -&gt; age &gt; 30; 是 boolean test(T t); 的一种实现 */ boolean test(T t); // 下边的都是 default 方法， static方法，具体使用参考java doc即可 default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) &amp;&amp; other.test(t); &#125; default Predicate&lt;T&gt; negate() &#123; return (t) -&gt; !test(t); &#125; default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) || other.test(t); &#125; static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) &#123; return (null == targetRef) ? Objects::isNull : object -&gt; targetRef.equals(object); &#125;&#125; default 声明的方法能够让接口向后兼容，比如 Collection 接口，像List. Set 等都是继承这个接口，那么对应的集合实现类就必须要实现接口中声明的非 default 和 static 的方法，所以向后兼容的时候， 不妨提供 default 和 static 实现的方法，然后所有子类不必自己重新实现也能使用新增的扩展功能。为什么会提供两种接口中实现方法的方式呢(default 和 static)？default 方法还是对象的方法，必须由一个该接口的具体实现才能调用，而static方法是类级别的方法，不需要具体实现即可调用 java8提供的函数引用因为许多函数比较常用，java8提供了很多必须的函数引用。 方法引用 对象 ：： 实例方法 类 ：： 静态方法 类 ：： 实例方法 例如 Math ：： pow 等同于 (x, y) -&gt; Math.pow(x, y); user :: getName 构造器引用String :: new; 闭包java8 的函数表达式即为java的闭包, 闭包引用是值引用 闭包的广义含义 闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。– 维基百科 Java 闭包举个栗子： 写一个生成函数的函数， 下边例子中的Predicate generateFunc(int i); 以下是测试部分代码，传入不同的值，生成不同的函数，那么每个函数都会由自己的表达式，本例中显示的是i的不同， 测试结果很明显 12345678910List&lt;Predicate&lt;Integer&gt;&gt; funcList = new ArrayList&lt;&gt;();StreamAPIDemo streamAPIDemo = new StreamAPIDemo();for (int i = 0; i &lt; 10; i++) &#123; Predicate&lt;Integer&gt; generateFunc = streamAPIDemo.generateFunc(i); funcList.add(generateFunc); boolean test = generateFunc.test(25); System.out.println("i = "+ i + " generateFunc 测试标准(方法) 25 + i + agePlus(1) &gt; 30 即 测试 25 + " + i + " + 1 (agePlus) " + " 是否大于30, 结果是 = " + test );&#125;System.out.println("获取到的方法集合size = " + funcList.size()); 12345Predicate&lt;Integer&gt; generateFunc(int i)&#123; int agePlus = 1; Predicate&lt;Integer&gt; func = age -&gt; age + i + agePlus &gt; 30; return func;&#125; i = 0 generateFunc 测试标准(方法) 25 + i + agePlus(1) &gt; 30 即 测试 25 + 0 + 1 (agePlus) 是否大于30, 结果是 = falsei = 1 generateFunc 测试标准(方法) 25 + i + agePlus(1) &gt; 30 即 测试 25 + 1 + 1 (agePlus) 是否大于30, 结果是 = falsei = 2 generateFunc 测试标准(方法) 25 + i + agePlus(1) &gt; 30 即 测试 25 + 2 + 1 (agePlus) 是否大于30, 结果是 = falsei = 3 generateFunc 测试标准(方法) 25 + i + agePlus(1) &gt; 30 即 测试 25 + 3 + 1 (agePlus) 是否大于30, 结果是 = falsei = 4 generateFunc 测试标准(方法) 25 + i + agePlus(1) &gt; 30 即 测试 25 + 4 + 1 (agePlus) 是否大于30, 结果是 = falsei = 5 generateFunc 测试标准(方法) 25 + i + agePlus(1) &gt; 30 即 测试 25 + 5 + 1 (agePlus) 是否大于30, 结果是 = truei = 6 generateFunc 测试标准(方法) 25 + i + agePlus(1) &gt; 30 即 测试 25 + 6 + 1 (agePlus) 是否大于30, 结果是 = truei = 7 generateFunc 测试标准(方法) 25 + i + agePlus(1) &gt; 30 即 测试 25 + 7 + 1 (agePlus) 是否大于30, 结果是 = truei = 8 generateFunc 测试标准(方法) 25 + i + agePlus(1) &gt; 30 即 测试 25 + 8 + 1 (agePlus) 是否大于30, 结果是 = truei = 9 generateFunc 测试标准(方法) 25 + i + agePlus(1) &gt; 30 即 测试 25 + 9 + 1 (agePlus) 是否大于30, 结果是 = true获取到的方法集合size = 10 根据传入的i的不同产生了不同的函数， 这里面就是闭包的使用， 引用了自由变量(agePlus) 的函数(age + i + agePlus &gt; 30)。 这里这个agePlus从不同的角度看就是不同的变量类型， 如果从Predicate generateFunc(int i); 来看 agePlus 即为这个函数的私有变量， 如果 从age + i + agePlus &gt; 30; 这个函数来看， 那么无论是 agePlust 还是i 都是 自由变量， 因为这些变量不属于 age + i + agePlus &gt; 30; 定义的变量， i 或者 agePlus都可以脱离 age + i + agePlus &gt; 30; 这个函数而存在。 再举个栗子： 123for (int num = 0; num &lt; 10; num++) &#123; dealData(num, "test 闭包");&#125; 123456789static void dealData(int num, String msg)&#123; Runnable ra = () -&gt; &#123;// num ++;// msg = "捕捉自由变量必须是final的"; System.out.println(Thread.currentThread().getName() + msg + " + " + num); &#125;; new Thread(ra).start();&#125; 自由变量在闭包函数中必须是final的， 不能有变化，如上的注释部分如果相对我们开的e() -&gt; {} 这个函数就是自由变量，所以不能进行变更。 当然如果一定要变化也不是不可以， 可以使用数组的形式，或者对象的形式 比如传入 int[0] 然后对int[]进行set值变更， 也是可以的， 但是有线程安全问题。 闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。变量的作用域仅限于包含它们的函数，因此无法从其它程序代码部分进行访问。不过，变量的生存期是可以很长，在一次函数调用期间所创建所生成的值在下次函数调用时仍然存在。正因为这一特点，闭包可以用来完成信息隐藏，并进而应用于需要状态表达的某些编程范型中。不过，用这种方式来使用闭包时，闭包不再具有引用透明性，因此也不再是纯函数。即便如此，在某些“近似于函数式编程语言”的语言，例如Scheme中，闭包还是得到了广泛的使用。– 维基百科 Stream API通常情况下处理集合数据的时候都会使用 for 或者 while 循环等操作， 这些操作的底层实现都是使用iterator 中的 hasNext() 和 next()进行遍历。Stream 提供了另一种处理集合的思路， 即将各种行为作用在每条数据上，这样写意图清晰，可读性很高。而且Stream提供并行操作，能充分利用多核性能。使用Stream API有三个步骤： 获取一个Stream 中间行为描述 行为执行并输出结果 获取Stream(官方文档描述为：source)获取Stream 首先要知道Stream是集合数据的一个视图(view)并非一种数据结构，最常用的获取Stream的方法有: Stream.of(T t);或者Stream.of(T… values); Stream提供的静态方法获取 所有集合均继承了Collection接口，该接口java8中提供了 default Stream stream();和default Stream parallelStream();的方法，后者提供的Stream自动支持并行操作，理论上在性能上能由更好的提供(性能方便还是要具体分析数据，cpu状态，核数等的影响)。所以左右实现了Collection接口的实现类都可以使用 Arrays.Stream(T… values); 也提供了static的方法来产生Stream 文件操作类 Files 也提供了static Stream lines(Path path); 的方法，该Stream 中包含文件的每行(Read all lines from a file as a Stream)还有很多很多方法能获取到Stream，自行寻找…. 中间行为描述(官方文档描述为:intermediate operations)之所以将这个中间操作解释为中间行为描述，是因为文档中描述Stream是 lazy 的，书中翻译为Stream是惰性求值的，即中间的Lambda传入不会引起实际的逻辑执行，只有当执行最终求值的时候才会执行中间描述行为(Lmabda),实验代码中可以提现出来，编写一个print语句当做Lambda即可看出 Streams are lazy; computation on the source data is only performed when the terminal operation is initiated 举例一些常用的方法 filter、mapp、sorted等: 123456789String str = "When you want to build muscle or strength it is better 30 min to maximum 1 hour of workout";List&lt;String&gt; words = Arrays.asList(str.split(" "));Stream&lt;String&gt; originalStream = words.stream(); // 由集合获取原始StreamStream&lt;String&gt; stringStream = originalStream.filter(w -&gt; w.length() &gt; 2); // 获取中间Streamwords.stream().map(String::toUpperCase); // 传入String， 然后返回一个大写的这个Stringwords.stream().sorted(Comparator.comparing(String :: length).reversed()); // 排序 Stream filter(Predicate&lt;? super T&gt; predicate); 表示传入一个参数返回boolean的一个函数，过滤、判断作用 Stream map(Function&lt;? super T, ? extends R&gt; mapper); map表示传入一个T类型，返回一个R类型，转换类型Stream sorted(Comparator&lt;? super T&gt; comparator); sorted表示传入一个比较类型的函数即传入两个 T 返回一个int的函数，这个sorted方法和distinc() 方法和filter 和map是不一样的，filter是无状态的，即不需要记住刚才处理数据的状态(值、大小等),但是sorted是需要记住的，所以他们的底层上稍有不同，但是使用者无需关心，filter 属于无状态转换，sorted属于有状态转换 行为执行并输出结果(官方文档描述为:terminal operation)中间函数描述完需要处理的数据，最终需要将函数执行并输出结果，有的是输出成集合、map、int等等: 12long count = words.stream().filter(w -&gt; w.length() &gt; 3).count(); // 计数List&lt;String&gt; collect = words.stream().map(String::toUpperCase).collect(Collectors.toList()); // List 类， 也可以在Collectors中选择 toSet 等操作。 Collectors 类中提供了大量的结果执行输出方法，求和、最大、最小、输出map(groupingBy)、连接成字符串等，简单的列举一下分组成map，类似与sql中的group by; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Main &#123; public static void main(String[] args) &#123; System.out.println("Hello World!"); List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; i++) &#123; User user = new User(); if (i % 2 == 0) &#123; user.setName("小黑"); &#125; else &#123; user.setName("bob"); &#125; user.setScare(i); list.add(user); &#125; // 根据 User的name分组，然后value为相同name中的最大scare，具体的描述参见官方文档 ConcurrentMap&lt;String, Optional&lt;Integer&gt;&gt; collect = list.stream(). collect(Collectors.groupingByConcurrent(User::getName, Collectors.mapping(User::getScare, Collectors.maxBy(Integer::compare)))); for (Map.Entry&lt;String, Optional&lt;Integer&gt;&gt; stringOptionalEntry : collect.entrySet()) &#123; System.out.println(stringOptionalEntry.getKey()); System.out.println(stringOptionalEntry.getValue().get()); &#125; &#125;&#125;class User &#123; String name; Integer scare; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getScare() &#123; return scare; &#125; public void setScare(Integer scare) &#123; this.scare = scare; &#125; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", scare=" + scare + '&#125;'; &#125;&#125; 还是需要实战coding final class Optionaljava 8 提供了这个类，赶脚是为了提供一个非null的安全事项， 以下是文档中的描述 A container object which may or may not contain a non-null value. If a value is present, isPresent() will return true and get() will return the value.Additional methods that depend on the presence or absence of a contained value are provided, such as orElse() (return a default value if value not present) and ifPresent() (execute a block of code if the value is present).This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of Optional may have unpredictable results and should be avoided. 简单使用：由以下场景获取一个用户的的具体信息的时候，很有可能是给定一个user对象，然后可能user的一个字段为pet宠物，然后获取宠物的pet的名字, 根据以上的需求，有很多这种代码 user.getPet().getName(); 这里有一个潜在的风险是如果这个user没有pet，那么getName的时候会有空指针的异常。Optional恰好能搞定这种情况 12345678User user = new User();user.setName("arthaks");user.setScare(100);//user.setPet(new Pet("土豆", String.valueOf(2)));String petName = Optional.ofNullable(user).map(User::getPet).map(Pet::getPetName).orElse("default");System.out.println(petName);如果没有pet返回的是提供的默认值 default， 如果由pet的话返回的是petName]]></content>
      <categories>
        <category>java8</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arrays.asList() 使用注意]]></title>
    <url>%2F2019%2F07%2F01%2FArrays.asList%20%E5%A4%A7%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Arrays.asList() 在需对规范中都不是首推使用的方法，这里面有很多很多的坑需要踩 123456789101112131415161718192021222324252627282930313233 /** * Returns a fixed-size list backed by the specified array. (Changes to * the returned list "write through" to the array.) This method acts * as bridge between array-based and collection-based APIs, in * combination with &#123;@link Collection#toArray&#125;. The returned list is * serializable and implements &#123;@link RandomAccess&#125;. * * &lt;p&gt;This method also provides a convenient way to create a fixed-size * list initialized to contain several elements: * &lt;pre&gt; * List&amp;lt;String&amp;gt; stooges = Arrays.asList("Larry", "Moe", "Curly"); * &lt;/pre&gt; * * @param &lt;T&gt; the class of the objects in the array * @param a the array by which the list will be backed * @return a list view of the specified array */ @SafeVarargs @SuppressWarnings("varargs") public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a); &#125; // 以上方法中的return 的构造器 ArrayList(E[] array) &#123; a = Objects.requireNonNull(array); &#125;// 以上方法中的 数组非null 判断public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj; &#125; 可以看到注释中 Returns a fixed-size list backed by the specified array. 可变参数列表可变参数列表使用的底层机制为数组传递 1234public static &lt;T&gt; String toList(T...a)&#123; T[] a1 = a; // idea 自动补齐的功能键, 返回的是数据,可以明确看出来 可变参数列表的底层机制是数组, 编程思想中也提到过可变参数列表的实现机制为数组 return a1[0].toString();&#125; 数组特点为创建后length不可变, 如果(T…a) 参数传入 的是(obj, null, obj, null), 那么实际的入参为一个长度 是4 的数组, 即 [obj, null, obj, null]. 这样以来就能看出Arrays.asList(T…a) 方法中的问题传入 带有null元素的数组, 但是整体数组非null, 最终形成一个List size()为4, 但是 2, 4 位上的元素为null, 一般情况下, 拿到list, 使用CollectionUtils.isEmpty()进行判断, 以上的带有null元素的数组通过判断, 进行迭代的时候通常就不会判断元素的null了, 容易造成空指针异常. 1234567891011 List&lt;Integer&gt; listOfKeng = Arrays.asList(null, null, null); List&lt;Integer&gt; list = Arrays.asList(1, 2, 3); System.out.println(listOfKeng); System.out.println(list); System.out.println(listOfKeng.size()); System.out.println(list.size());// [null, null, null]// [1, 2, 3]// 3// 3 123456789101112131415161718192021项目中的大坑public List&lt;LendUserInfo&gt; getLenderAndBorrowerInfoByLogUserAccount(LogUserAccountDetailStorm logUserAccountDetailStorm) &#123; // 获取理财用户 LendUserInfo lendUserInfo = null; try &#123; lendUserInfo = buildLendUserInfo(someObj, 1, 1); &#125; catch (Exception e) &#123; logger.warn("getLenderAndBorrowerInfoByLogUserAccount, userInfo invalid, userGid:&#123;&#125;, orderId:&#123;&#125;" , logUserAccountDetailStorm.getUserGid(), logUserAccountDetailStorm.getOrderId(), e); return null; &#125; LendUserInfo borrowerInfo = null; try &#123; borrowerInfo = this.buildLendUserInfoByMatch(someObj); &#125; catch (Exception e) &#123; logger.error("getLenderAndBorrowerInfoByLogUserAccount, userInfo invalid, userGid:&#123;&#125;, orderId:&#123;&#125;" , logUserAccountDetailStorm.getUserGid(), logUserAccountDetailStorm.getOrderId()); return null; &#125; return Arrays.asList(lendUserInfo, borrowerInfo); // 这里线上出现过 lendUserInfo 有数据, borrowerInfo = null的情况 即返回了[obj, null]&#125; 1有很多情况下, 从数据库查询出来的entity直接放到了Arrays.asList(T...a) 中了, 非常容易造成空指针异常]]></content>
      <categories>
        <category>java 基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java SPI 机制]]></title>
    <url>%2F2019%2F07%2F01%2Fjava%20SPI%20%2F</url>
    <content type="text"><![CDATA[java SPI(Service Provider Interfaces) 服务提供接口,jdk自身提供的一种获取到某个service 接口的实现类的方式. 使用方法 在项目的META-INF/services/ 下创建文件,文件名为目标service 的全限定名 在文件中写入对应的实现类的权限定名 使用ServiceLoader.load(Class class) 获取到全部的实现类 demo创建 service 接口 123public interface ComputerService &#123; void sayName();&#125; 创建对应实现类 1234567891011121314public class Dell implements ComputerService &#123; @Override public void sayName() &#123; System.out.println("我是 dell"); &#125;&#125;public class MacBook implements ComputerService &#123; @Override public void sayName() &#123; System.out.println("我是大mac"); &#125;&#125; 创建文件 获取对应的实现类 1234567891011121314151617181920212223public class Main &#123; public static void main(String[] args) &#123; System.out.println("Hello World!"); ServiceLoader&lt;ComputerService&gt; loadService = ServiceLoader.load(ComputerService.class); for (ComputerService computerService : loadService) &#123; computerService.sayName(); System.out.println("---------------------------我是666的分割线, dubbo 中扩展了java SPI机制,形成类似的AOP/Ioc机制------------------------------------"); &#125;// Hello World!// 我是大mac// ---------------------------我是666的分割线, dubbo 中扩展了java SPI机制,形成类似的AOP/Ioc机制------------------------------------// 我是 dell// ---------------------------我是666的分割线, dubbo 中扩展了java SPI机制,形成类似的AOP/Ioc机制------------------------------------ &#125;&#125; ServiceLoader 源码解析for 循环使用了ServiceLoader 的迭代器, 静默使用了hasNext(), next() 等方法, 在LazyInterator中有分别对应的hasNextService(), nextService() 最终调用指向 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798private class LazyIterator implements Iterator&lt;S&gt; &#123; Class&lt;S&gt; service; // ClassLoader loader; // 类加载器 Enumeration&lt;URL&gt; configs = null; // 文件中的配置好的类转化成的url Iterator&lt;String&gt; pending = null; // 包含类名的迭代器 String nextName = null; private LazyIterator(Class&lt;S&gt; service, ClassLoader loader) &#123; this.service = service; this.loader = loader; &#125; private boolean hasNextService() &#123; if (nextName != null) &#123; return true; &#125; if (configs == null) &#123; try &#123; String fullName = PREFIX + service.getName(); // private static final String PREFIX = "META-INF/services/"; if (loader == null) configs = ClassLoader.getSystemResources(fullName); else configs = loader.getResources(fullName); &#125; catch (IOException x) &#123; fail(service, "Error locating configuration files", x); &#125; &#125; while ((pending == null) || !pending.hasNext()) &#123; if (!configs.hasMoreElements()) &#123; return false; &#125; pending = parse(service, configs.nextElement()); &#125; nextName = pending.next(); return true; &#125; private S nextService() &#123; if (!hasNextService()) throw new NoSuchElementException(); String cn = nextName; nextName = null; Class&lt;?&gt; c = null; try &#123; c = Class.forName(cn, false, loader); // forName 实例化对应的实现类 &#125; catch (ClassNotFoundException x) &#123; fail(service, "Provider " + cn + " not found"); &#125; if (!service.isAssignableFrom(c)) &#123; fail(service, "Provider " + cn + " not a subtype"); &#125; try &#123; S p = service.cast(c.newInstance()); // cast to 对应的接口 providers.put(cn, p); // private LinkedHashMap&lt;String,S&gt; providers = new LinkedHashMap&lt;&gt;(); 有序链表 return p; &#125; catch (Throwable x) &#123; fail(service, "Provider " + cn + " could not be instantiated", x); &#125; throw new Error(); // This cannot happen &#125; public boolean hasNext() &#123; // 迭代for循环 指向 hasNestService(); if (acc == null) &#123; return hasNextService(); &#125; else &#123; PrivilegedAction&lt;Boolean&gt; action = new PrivilegedAction&lt;Boolean&gt;() &#123; public Boolean run() &#123; return hasNextService(); &#125; &#125;; return AccessController.doPrivileged(action, acc); &#125; &#125; public S next() &#123; // 迭代for循环 指向 nextService(); if (acc == null) &#123; return nextService(); &#125; else &#123; PrivilegedAction&lt;S&gt; action = new PrivilegedAction&lt;S&gt;() &#123; public S run() &#123; return nextService(); &#125; &#125;; return AccessController.doPrivileged(action, acc); &#125; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; &#125; demo:https://github.com/arthaks/java-demo/tree/master/java-demo-SPI]]></content>
      <categories>
        <category>java 基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 下搭建hexo进行博客书写]]></title>
    <url>%2F2019%2F06%2F26%2Flinux-%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E8%BF%9B%E8%A1%8C%E5%8D%9A%E5%AE%A2%E4%B9%A6%E5%86%99%2F</url>
    <content type="text"><![CDATA[自己想写博客, 试过简书, 博客园, CSDN, google blogger 等乱七八糟的东西, 不是广告太多就是不支持markdown. 后来知道了hexo, 这篇文章就是测试文章. 需求如下: 使用markdown写东西, 用了好长时间了, 改不了了 广告不要太多, 最好没有 最好远端和本地或者其他网络空间里能多处备份(现在这样看来, 这种方法可以存在本地, github, 印象笔记, 有道笔记等支持markdown存储的地方) 跨平台操作(linux, win, mac 都支持) 目前我个人使用的是linux mint 19 作为日常使用电脑, 所以以下操作均基于该系统, 当然这玩意其实就是Ubuntu的一个衍生版本,给予Ubuntu的所有版本基本都是这样搞. 基本步骤 准备node.js 环境(hexo基于这玩意咋地还是) 安装hexo 自备markdown编辑器, 自行google选择, 我自己在用 haroopad 有自己的github, 自行google 安装git, 自行google 详细搞1. 准备node.js 环境linux 相对简单, 在node.js 官网 下载对应tar包, 然后解压, 我的解压完成之后是 /home/arthaks/soft/node-v10.16.0-linux-x64将 node.js配置环境变量, ln 创建软硬链接用法, 自行google. 12sudo ln -s /home/arthaks/soft/node-v10.16.0-linux-x64/bin/node /usr/local/bin/sudo ln -s /home/arthaks/soft/node-v10.16.0-linux-x64/bin/npm /usr/local/bin/ 2. 安装hexo,并启动对应引擎123# 安装hexo,并配置hexo环境变量npm install hexo-cli -gsudo ln -s /home/arthaks/soft/node-v10.16.0-linux-x64/bin/hexo /usr/local/bin/ 创建自己的文件夹初始化文件夹作为博客位置, hexo命令学习可以看官方文档,也可以 hexo help 查看对应的命令使用[hexo help 命令学习个人赶脚效率很高,看个人习惯] 1234567mkdir blogcd blog# init 文件夹为hexo工作空间hexo init# Start the server and watch for file changes.hexo s# 然后会提示你用本地4000接口查看博客了, 当然这是本地启动hexo server之后的效果, 博客的原理还是使用hexo引擎将对应的markdown文件转化成html文件配置到远端 3. markdown疯狂输出就ok了markdown 语法自己找就行啦, 贼简单 4. 生成博客, md文件都在 /home/arthaks/Doc/blog/source/_posts/12hexo ghexo s 5. 配置主题 hexo找到对应主题git clone 主题到我们博客文件夹下的themes里, 然后找到博客根目录下的_config.yml 修改文件中theme配置为刚clone的文件名, 然后重新生成博客并启动hexo server 就能本地看出变化来啦]]></content>
      <categories>
        <category>闲篇瞎扯</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>github</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
